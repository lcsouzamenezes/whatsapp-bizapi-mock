// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: messages.proto

package model

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Context with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Context) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Context with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ContextMultiError, or nil if none found.
func (m *Context) ValidateAll() error {
	return m.validate(true)
}

func (m *Context) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for Id

	// no validation rules for Forwarded

	// no validation rules for FrequentlyForwarded

	if len(errors) > 0 {
		return ContextMultiError(errors)
	}
	return nil
}

// ContextMultiError is an error wrapping multiple validation errors returned
// by Context.ValidateAll() if the designated constraints aren't met.
type ContextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContextMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContextMultiError) AllErrors() []error { return m }

// ContextValidationError is the validation error returned by Context.Validate
// if the designated constraints aren't met.
type ContextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContextValidationError) ErrorName() string { return "ContextValidationError" }

// Error satisfies the builtin error interface
func (e ContextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContext.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContextValidationError{}

// Validate checks the field values on Provider with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Provider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Provider with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProviderMultiError, or nil
// if none found.
func (m *Provider) ValidateAll() error {
	return m.validate(true)
}

func (m *Provider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ProviderMultiError(errors)
	}
	return nil
}

// ProviderMultiError is an error wrapping multiple validation errors returned
// by Provider.ValidateAll() if the designated constraints aren't met.
type ProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProviderMultiError) AllErrors() []error { return m }

// ProviderValidationError is the validation error returned by
// Provider.Validate if the designated constraints aren't met.
type ProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProviderValidationError) ErrorName() string { return "ProviderValidationError" }

// Error satisfies the builtin error interface
func (e ProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProviderValidationError{}

// Validate checks the field values on TextMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TextMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TextMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TextMessageMultiError, or
// nil if none found.
func (m *TextMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *TextMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBody()) < 1 {
		err := TextMessageValidationError{
			field:  "Body",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TextMessageMultiError(errors)
	}
	return nil
}

// TextMessageMultiError is an error wrapping multiple validation errors
// returned by TextMessage.ValidateAll() if the designated constraints aren't met.
type TextMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TextMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TextMessageMultiError) AllErrors() []error { return m }

// TextMessageValidationError is the validation error returned by
// TextMessage.Validate if the designated constraints aren't met.
type TextMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TextMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TextMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TextMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TextMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TextMessageValidationError) ErrorName() string { return "TextMessageValidationError" }

// Error satisfies the builtin error interface
func (e TextMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTextMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TextMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TextMessageValidationError{}

// Validate checks the field values on ImageMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageMessageMultiError, or
// nil if none found.
func (m *ImageMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := ImageMessageValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Link

	// no validation rules for MimeType

	// no validation rules for Sha256

	// no validation rules for Caption

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImageMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImageMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImageMessageValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImageMessageMultiError(errors)
	}
	return nil
}

// ImageMessageMultiError is an error wrapping multiple validation errors
// returned by ImageMessage.ValidateAll() if the designated constraints aren't met.
type ImageMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageMessageMultiError) AllErrors() []error { return m }

// ImageMessageValidationError is the validation error returned by
// ImageMessage.Validate if the designated constraints aren't met.
type ImageMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageMessageValidationError) ErrorName() string { return "ImageMessageValidationError" }

// Error satisfies the builtin error interface
func (e ImageMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageMessageValidationError{}

// Validate checks the field values on AudioMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AudioMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AudioMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AudioMessageMultiError, or
// nil if none found.
func (m *AudioMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *AudioMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := AudioMessageValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Link

	// no validation rules for MimeType

	// no validation rules for Sha256

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AudioMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AudioMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AudioMessageValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AudioMessageMultiError(errors)
	}
	return nil
}

// AudioMessageMultiError is an error wrapping multiple validation errors
// returned by AudioMessage.ValidateAll() if the designated constraints aren't met.
type AudioMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AudioMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AudioMessageMultiError) AllErrors() []error { return m }

// AudioMessageValidationError is the validation error returned by
// AudioMessage.Validate if the designated constraints aren't met.
type AudioMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AudioMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AudioMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AudioMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AudioMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AudioMessageValidationError) ErrorName() string { return "AudioMessageValidationError" }

// Error satisfies the builtin error interface
func (e AudioMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAudioMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AudioMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AudioMessageValidationError{}

// Validate checks the field values on VideoMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VideoMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VideoMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VideoMessageMultiError, or
// nil if none found.
func (m *VideoMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *VideoMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := VideoMessageValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Link

	// no validation rules for MimeType

	// no validation rules for Sha256

	// no validation rules for Caption

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VideoMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VideoMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VideoMessageValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VideoMessageMultiError(errors)
	}
	return nil
}

// VideoMessageMultiError is an error wrapping multiple validation errors
// returned by VideoMessage.ValidateAll() if the designated constraints aren't met.
type VideoMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VideoMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VideoMessageMultiError) AllErrors() []error { return m }

// VideoMessageValidationError is the validation error returned by
// VideoMessage.Validate if the designated constraints aren't met.
type VideoMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VideoMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VideoMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VideoMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VideoMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VideoMessageValidationError) ErrorName() string { return "VideoMessageValidationError" }

// Error satisfies the builtin error interface
func (e VideoMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVideoMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VideoMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VideoMessageValidationError{}

// Validate checks the field values on VoiceMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VoiceMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VoiceMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VoiceMessageMultiError, or
// nil if none found.
func (m *VoiceMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *VoiceMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := VoiceMessageValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Link

	// no validation rules for MimeType

	// no validation rules for Sha256

	if len(errors) > 0 {
		return VoiceMessageMultiError(errors)
	}
	return nil
}

// VoiceMessageMultiError is an error wrapping multiple validation errors
// returned by VoiceMessage.ValidateAll() if the designated constraints aren't met.
type VoiceMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VoiceMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VoiceMessageMultiError) AllErrors() []error { return m }

// VoiceMessageValidationError is the validation error returned by
// VoiceMessage.Validate if the designated constraints aren't met.
type VoiceMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoiceMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoiceMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoiceMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoiceMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoiceMessageValidationError) ErrorName() string { return "VoiceMessageValidationError" }

// Error satisfies the builtin error interface
func (e VoiceMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoiceMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoiceMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoiceMessageValidationError{}

// Validate checks the field values on DocumentMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentMessageMultiError, or nil if none found.
func (m *DocumentMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := DocumentMessageValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Link

	// no validation rules for MimeType

	// no validation rules for Sha256

	// no validation rules for Caption

	// no validation rules for Filename

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentMessageValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentMessageMultiError(errors)
	}
	return nil
}

// DocumentMessageMultiError is an error wrapping multiple validation errors
// returned by DocumentMessage.ValidateAll() if the designated constraints
// aren't met.
type DocumentMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMessageMultiError) AllErrors() []error { return m }

// DocumentMessageValidationError is the validation error returned by
// DocumentMessage.Validate if the designated constraints aren't met.
type DocumentMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentMessageValidationError) ErrorName() string { return "DocumentMessageValidationError" }

// Error satisfies the builtin error interface
func (e DocumentMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentMessageValidationError{}

// Validate checks the field values on MediaParameter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MediaParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MediaParameter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MediaParameterMultiError,
// or nil if none found.
func (m *MediaParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *MediaParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 10 {
		err := MediaParameterValidationError{
			field:  "Id",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Filename

	// no validation rules for Caption

	if len(errors) > 0 {
		return MediaParameterMultiError(errors)
	}
	return nil
}

// MediaParameterMultiError is an error wrapping multiple validation errors
// returned by MediaParameter.ValidateAll() if the designated constraints
// aren't met.
type MediaParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MediaParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MediaParameterMultiError) AllErrors() []error { return m }

// MediaParameterValidationError is the validation error returned by
// MediaParameter.Validate if the designated constraints aren't met.
type MediaParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MediaParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MediaParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MediaParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MediaParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MediaParameterValidationError) ErrorName() string { return "MediaParameterValidationError" }

// Error satisfies the builtin error interface
func (e MediaParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMediaParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MediaParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MediaParameterValidationError{}

// Validate checks the field values on TemplateMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessageMultiError, or nil if none found.
func (m *TemplateMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetLanguage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemplateMessageValidationError{
					field:  "Language",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemplateMessageValidationError{
					field:  "Language",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLanguage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemplateMessageValidationError{
				field:  "Language",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetComponents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessageValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessageValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessageValidationError{
					field:  fmt.Sprintf("Components[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TemplateMessageMultiError(errors)
	}
	return nil
}

// TemplateMessageMultiError is an error wrapping multiple validation errors
// returned by TemplateMessage.ValidateAll() if the designated constraints
// aren't met.
type TemplateMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessageMultiError) AllErrors() []error { return m }

// TemplateMessageValidationError is the validation error returned by
// TemplateMessage.Validate if the designated constraints aren't met.
type TemplateMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateMessageValidationError) ErrorName() string { return "TemplateMessageValidationError" }

// Error satisfies the builtin error interface
func (e TemplateMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessageValidationError{}

// Validate checks the field values on InteractiveMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InteractiveMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InteractiveMessageMultiError, or nil if none found.
func (m *InteractiveMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _InteractiveMessage_Type_InLookup[m.GetType()]; !ok {
		err := InteractiveMessageValidationError{
			field:  "Type",
			reason: "value must be in list [list button]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessageValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessageValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFooter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Footer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Footer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFooter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessageValidationError{
				field:  "Footer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessageValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessageValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InteractiveMessageMultiError(errors)
	}
	return nil
}

// InteractiveMessageMultiError is an error wrapping multiple validation errors
// returned by InteractiveMessage.ValidateAll() if the designated constraints
// aren't met.
type InteractiveMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessageMultiError) AllErrors() []error { return m }

// InteractiveMessageValidationError is the validation error returned by
// InteractiveMessage.Validate if the designated constraints aren't met.
type InteractiveMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessageValidationError) ErrorName() string {
	return "InteractiveMessageValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessageValidationError{}

var _InteractiveMessage_Type_InLookup = map[string]struct{}{
	"list":   {},
	"button": {},
}

// Validate checks the field values on LocationMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LocationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocationMessageMultiError, or nil if none found.
func (m *LocationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *LocationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Name

	if len(errors) > 0 {
		return LocationMessageMultiError(errors)
	}
	return nil
}

// LocationMessageMultiError is an error wrapping multiple validation errors
// returned by LocationMessage.ValidateAll() if the designated constraints
// aren't met.
type LocationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationMessageMultiError) AllErrors() []error { return m }

// LocationMessageValidationError is the validation error returned by
// LocationMessage.Validate if the designated constraints aren't met.
type LocationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationMessageValidationError) ErrorName() string { return "LocationMessageValidationError" }

// Error satisfies the builtin error interface
func (e LocationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationMessageValidationError{}

// Validate checks the field values on SystemMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemMessageMultiError, or
// nil if none found.
func (m *SystemMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Body

	if len(errors) > 0 {
		return SystemMessageMultiError(errors)
	}
	return nil
}

// SystemMessageMultiError is an error wrapping multiple validation errors
// returned by SystemMessage.ValidateAll() if the designated constraints
// aren't met.
type SystemMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemMessageMultiError) AllErrors() []error { return m }

// SystemMessageValidationError is the validation error returned by
// SystemMessage.Validate if the designated constraints aren't met.
type SystemMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemMessageValidationError) ErrorName() string { return "SystemMessageValidationError" }

// Error satisfies the builtin error interface
func (e SystemMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemMessageValidationError{}

// Validate checks the field values on StickerMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StickerMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StickerMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StickerMessageMultiError,
// or nil if none found.
func (m *StickerMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *StickerMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Link

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StickerMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StickerMessageValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StickerMessageValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StickerMessageMultiError(errors)
	}
	return nil
}

// StickerMessageMultiError is an error wrapping multiple validation errors
// returned by StickerMessage.ValidateAll() if the designated constraints
// aren't met.
type StickerMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StickerMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StickerMessageMultiError) AllErrors() []error { return m }

// StickerMessageValidationError is the validation error returned by
// StickerMessage.Validate if the designated constraints aren't met.
type StickerMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StickerMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StickerMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StickerMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StickerMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StickerMessageValidationError) ErrorName() string { return "StickerMessageValidationError" }

// Error satisfies the builtin error interface
func (e StickerMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStickerMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StickerMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StickerMessageValidationError{}

// Validate checks the field values on MessageWrapper with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessageWrapper) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageWrapper with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessageWrapperMultiError,
// or nil if none found.
func (m *MessageWrapper) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageWrapper) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageWrapperValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageWrapperValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageWrapperValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MessageWrapperMultiError(errors)
	}
	return nil
}

// MessageWrapperMultiError is an error wrapping multiple validation errors
// returned by MessageWrapper.ValidateAll() if the designated constraints
// aren't met.
type MessageWrapperMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageWrapperMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageWrapperMultiError) AllErrors() []error { return m }

// MessageWrapperValidationError is the validation error returned by
// MessageWrapper.Validate if the designated constraints aren't met.
type MessageWrapperValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageWrapperValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageWrapperValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageWrapperValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageWrapperValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageWrapperValidationError) ErrorName() string { return "MessageWrapperValidationError" }

// Error satisfies the builtin error interface
func (e MessageWrapperValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageWrapper.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageWrapperValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageWrapperValidationError{}

// Validate checks the field values on Messagemeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Messagemeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Messagemeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessagemetaMultiError, or
// nil if none found.
func (m *Messagemeta) ValidateAll() error {
	return m.validate(true)
}

func (m *Messagemeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for To

	// no validation rules for Type

	if len(errors) > 0 {
		return MessagemetaMultiError(errors)
	}
	return nil
}

// MessagemetaMultiError is an error wrapping multiple validation errors
// returned by Messagemeta.ValidateAll() if the designated constraints aren't met.
type MessagemetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessagemetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessagemetaMultiError) AllErrors() []error { return m }

// MessagemetaValidationError is the validation error returned by
// Messagemeta.Validate if the designated constraints aren't met.
type MessagemetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessagemetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessagemetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessagemetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessagemetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessagemetaValidationError) ErrorName() string { return "MessagemetaValidationError" }

// Error satisfies the builtin error interface
func (e MessagemetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessagemeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessagemetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessagemetaValidationError{}

// Validate checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MessageMultiError, or nil if none found.
func (m *Message) ValidateAll() error {
	return m.validate(true)
}

func (m *Message) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for From

	if !_Message_To_Pattern.MatchString(m.GetTo()) {
		err := MessageValidationError{
			field:  "To",
			reason: "value does not match regex pattern \"^\\\\+?(?:[0-9]){6,14}[0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Timestamp

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetText()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetText()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Text",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetImage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Image",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAudio()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Audio",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Audio",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAudio()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Audio",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVoice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Voice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Voice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVoice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Voice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSystem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "System",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "System",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "System",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSticker()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Sticker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Sticker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSticker()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Sticker",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Template",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInteractive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Interactive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Interactive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInteractive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Interactive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RecipientType

	// no validation rules for PreviewUrl

	if len(errors) > 0 {
		return MessageMultiError(errors)
	}
	return nil
}

// MessageMultiError is an error wrapping multiple validation errors returned
// by Message.ValidateAll() if the designated constraints aren't met.
type MessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageMultiError) AllErrors() []error { return m }

// MessageValidationError is the validation error returned by Message.Validate
// if the designated constraints aren't met.
type MessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageValidationError) ErrorName() string { return "MessageValidationError" }

// Error satisfies the builtin error interface
func (e MessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageValidationError{}

var _Message_To_Pattern = regexp.MustCompile("^\\+?(?:[0-9]){6,14}[0-9]$")

// Validate checks the field values on TemplateMessage_Language with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessage_Language) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateMessage_Language with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessage_LanguageMultiError, or nil if none found.
func (m *TemplateMessage_Language) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage_Language) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := TemplateMessage_Language_Policy_name[int32(m.GetPolicy())]; !ok {
		err := TemplateMessage_LanguageValidationError{
			field:  "Policy",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TemplateMessage_Language_Code_name[int32(m.GetCode())]; !ok {
		err := TemplateMessage_LanguageValidationError{
			field:  "Code",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TemplateMessage_LanguageMultiError(errors)
	}
	return nil
}

// TemplateMessage_LanguageMultiError is an error wrapping multiple validation
// errors returned by TemplateMessage_Language.ValidateAll() if the designated
// constraints aren't met.
type TemplateMessage_LanguageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessage_LanguageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessage_LanguageMultiError) AllErrors() []error { return m }

// TemplateMessage_LanguageValidationError is the validation error returned by
// TemplateMessage_Language.Validate if the designated constraints aren't met.
type TemplateMessage_LanguageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessage_LanguageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateMessage_LanguageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateMessage_LanguageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateMessage_LanguageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateMessage_LanguageValidationError) ErrorName() string {
	return "TemplateMessage_LanguageValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessage_LanguageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage_Language.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessage_LanguageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessage_LanguageValidationError{}

// Validate checks the field values on TemplateMessage_Component with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessage_Component) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateMessage_Component with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessage_ComponentMultiError, or nil if none found.
func (m *TemplateMessage_Component) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage_Component) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _TemplateMessage_Component_Type_InLookup[m.GetType()]; !ok {
		err := TemplateMessage_ComponentValidationError{
			field:  "Type",
			reason: "value must be in list [header body footer button]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSubType() != "" {

		if _, ok := _TemplateMessage_Component_SubType_InLookup[m.GetSubType()]; !ok {
			err := TemplateMessage_ComponentValidationError{
				field:  "SubType",
				reason: "value must be in list [quick_reply url]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Index

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_ComponentValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_ComponentValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_ComponentValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TemplateMessage_ComponentMultiError(errors)
	}
	return nil
}

// TemplateMessage_ComponentMultiError is an error wrapping multiple validation
// errors returned by TemplateMessage_Component.ValidateAll() if the
// designated constraints aren't met.
type TemplateMessage_ComponentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessage_ComponentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessage_ComponentMultiError) AllErrors() []error { return m }

// TemplateMessage_ComponentValidationError is the validation error returned by
// TemplateMessage_Component.Validate if the designated constraints aren't met.
type TemplateMessage_ComponentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessage_ComponentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateMessage_ComponentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateMessage_ComponentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateMessage_ComponentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateMessage_ComponentValidationError) ErrorName() string {
	return "TemplateMessage_ComponentValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessage_ComponentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage_Component.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessage_ComponentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessage_ComponentValidationError{}

var _TemplateMessage_Component_Type_InLookup = map[string]struct{}{
	"header": {},
	"body":   {},
	"footer": {},
	"button": {},
}

var _TemplateMessage_Component_SubType_InLookup = map[string]struct{}{
	"quick_reply": {},
	"url":         {},
}

// Validate checks the field values on TemplateMessage_Component_Parameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TemplateMessage_Component_Parameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateMessage_Component_Parameter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TemplateMessage_Component_ParameterMultiError, or nil if none found.
func (m *TemplateMessage_Component_Parameter) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage_Component_Parameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _TemplateMessage_Component_Parameter_Type_InLookup[m.GetType()]; !ok {
		err := TemplateMessage_Component_ParameterValidationError{
			field:  "Type",
			reason: "value must be in list [text image document video currency date_time]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch m.Spec.(type) {

	case *TemplateMessage_Component_Parameter_Text:
		// no validation rules for Text

	case *TemplateMessage_Component_Parameter_Currency:

		if all {
			switch v := interface{}(m.GetCurrency()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Currency",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Currency",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_Component_ParameterValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TemplateMessage_Component_Parameter_DateTime:

		if all {
			switch v := interface{}(m.GetDateTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "DateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "DateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDateTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_Component_ParameterValidationError{
					field:  "DateTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TemplateMessage_Component_Parameter_Image:

		if all {
			switch v := interface{}(m.GetImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_Component_ParameterValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TemplateMessage_Component_Parameter_Document:

		if all {
			switch v := interface{}(m.GetDocument()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Document",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Document",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_Component_ParameterValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TemplateMessage_Component_Parameter_Video:

		if all {
			switch v := interface{}(m.GetVideo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Video",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessage_Component_ParameterValidationError{
						field:  "Video",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessage_Component_ParameterValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TemplateMessage_Component_Parameter_Payload:
		// no validation rules for Payload

	}

	if len(errors) > 0 {
		return TemplateMessage_Component_ParameterMultiError(errors)
	}
	return nil
}

// TemplateMessage_Component_ParameterMultiError is an error wrapping multiple
// validation errors returned by
// TemplateMessage_Component_Parameter.ValidateAll() if the designated
// constraints aren't met.
type TemplateMessage_Component_ParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessage_Component_ParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessage_Component_ParameterMultiError) AllErrors() []error { return m }

// TemplateMessage_Component_ParameterValidationError is the validation error
// returned by TemplateMessage_Component_Parameter.Validate if the designated
// constraints aren't met.
type TemplateMessage_Component_ParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessage_Component_ParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateMessage_Component_ParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateMessage_Component_ParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateMessage_Component_ParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateMessage_Component_ParameterValidationError) ErrorName() string {
	return "TemplateMessage_Component_ParameterValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessage_Component_ParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage_Component_Parameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessage_Component_ParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessage_Component_ParameterValidationError{}

var _TemplateMessage_Component_Parameter_Type_InLookup = map[string]struct{}{
	"text":      {},
	"image":     {},
	"document":  {},
	"video":     {},
	"currency":  {},
	"date_time": {},
}

// Validate checks the field values on
// TemplateMessage_Component_Parameter_CurrencyParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessage_Component_Parameter_CurrencyParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TemplateMessage_Component_Parameter_CurrencyParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessage_Component_Parameter_CurrencyParameterMultiError, or nil if
// none found.
func (m *TemplateMessage_Component_Parameter_CurrencyParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage_Component_Parameter_CurrencyParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FallbackValue

	// no validation rules for Code

	// no validation rules for Amount_1000

	if len(errors) > 0 {
		return TemplateMessage_Component_Parameter_CurrencyParameterMultiError(errors)
	}
	return nil
}

// TemplateMessage_Component_Parameter_CurrencyParameterMultiError is an error
// wrapping multiple validation errors returned by
// TemplateMessage_Component_Parameter_CurrencyParameter.ValidateAll() if the
// designated constraints aren't met.
type TemplateMessage_Component_Parameter_CurrencyParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessage_Component_Parameter_CurrencyParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessage_Component_Parameter_CurrencyParameterMultiError) AllErrors() []error {
	return m
}

// TemplateMessage_Component_Parameter_CurrencyParameterValidationError is the
// validation error returned by
// TemplateMessage_Component_Parameter_CurrencyParameter.Validate if the
// designated constraints aren't met.
type TemplateMessage_Component_Parameter_CurrencyParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) ErrorName() string {
	return "TemplateMessage_Component_Parameter_CurrencyParameterValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessage_Component_Parameter_CurrencyParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage_Component_Parameter_CurrencyParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessage_Component_Parameter_CurrencyParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessage_Component_Parameter_CurrencyParameterValidationError{}

// Validate checks the field values on
// TemplateMessage_Component_Parameter_DateTimeParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessage_Component_Parameter_DateTimeParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TemplateMessage_Component_Parameter_DateTimeParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessage_Component_Parameter_DateTimeParameterMultiError, or nil if
// none found.
func (m *TemplateMessage_Component_Parameter_DateTimeParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessage_Component_Parameter_DateTimeParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FallbackValue

	// no validation rules for DayOfWeek

	// no validation rules for DayOfMonth

	// no validation rules for Year

	// no validation rules for Month

	// no validation rules for Hour

	// no validation rules for Minute

	// no validation rules for Timestamp

	// no validation rules for Calendar

	if len(errors) > 0 {
		return TemplateMessage_Component_Parameter_DateTimeParameterMultiError(errors)
	}
	return nil
}

// TemplateMessage_Component_Parameter_DateTimeParameterMultiError is an error
// wrapping multiple validation errors returned by
// TemplateMessage_Component_Parameter_DateTimeParameter.ValidateAll() if the
// designated constraints aren't met.
type TemplateMessage_Component_Parameter_DateTimeParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessage_Component_Parameter_DateTimeParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessage_Component_Parameter_DateTimeParameterMultiError) AllErrors() []error {
	return m
}

// TemplateMessage_Component_Parameter_DateTimeParameterValidationError is the
// validation error returned by
// TemplateMessage_Component_Parameter_DateTimeParameter.Validate if the
// designated constraints aren't met.
type TemplateMessage_Component_Parameter_DateTimeParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) ErrorName() string {
	return "TemplateMessage_Component_Parameter_DateTimeParameterValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessage_Component_Parameter_DateTimeParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessage_Component_Parameter_DateTimeParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessage_Component_Parameter_DateTimeParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessage_Component_Parameter_DateTimeParameterValidationError{}

// Validate checks the field values on InteractiveMessage_HeaderParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InteractiveMessage_HeaderParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_HeaderParameter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InteractiveMessage_HeaderParameterMultiError, or nil if none found.
func (m *InteractiveMessage_HeaderParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_HeaderParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _InteractiveMessage_HeaderParameter_Type_InLookup[m.GetType()]; !ok {
		err := InteractiveMessage_HeaderParameterValidationError{
			field:  "Type",
			reason: "value must be in list [text video image document]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Text

	if all {
		switch v := interface{}(m.GetImage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessage_HeaderParameterValidationError{
				field:  "Image",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessage_HeaderParameterValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessage_HeaderParameterValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessage_HeaderParameterValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InteractiveMessage_HeaderParameterMultiError(errors)
	}
	return nil
}

// InteractiveMessage_HeaderParameterMultiError is an error wrapping multiple
// validation errors returned by
// InteractiveMessage_HeaderParameter.ValidateAll() if the designated
// constraints aren't met.
type InteractiveMessage_HeaderParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_HeaderParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_HeaderParameterMultiError) AllErrors() []error { return m }

// InteractiveMessage_HeaderParameterValidationError is the validation error
// returned by InteractiveMessage_HeaderParameter.Validate if the designated
// constraints aren't met.
type InteractiveMessage_HeaderParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_HeaderParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_HeaderParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_HeaderParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_HeaderParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_HeaderParameterValidationError) ErrorName() string {
	return "InteractiveMessage_HeaderParameterValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_HeaderParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_HeaderParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_HeaderParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_HeaderParameterValidationError{}

var _InteractiveMessage_HeaderParameter_Type_InLookup = map[string]struct{}{
	"text":     {},
	"video":    {},
	"image":    {},
	"document": {},
}

// Validate checks the field values on InteractiveMessage_TextParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InteractiveMessage_TextParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_TextParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InteractiveMessage_TextParameterMultiError, or nil if none found.
func (m *InteractiveMessage_TextParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_TextParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	if len(errors) > 0 {
		return InteractiveMessage_TextParameterMultiError(errors)
	}
	return nil
}

// InteractiveMessage_TextParameterMultiError is an error wrapping multiple
// validation errors returned by
// InteractiveMessage_TextParameter.ValidateAll() if the designated
// constraints aren't met.
type InteractiveMessage_TextParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_TextParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_TextParameterMultiError) AllErrors() []error { return m }

// InteractiveMessage_TextParameterValidationError is the validation error
// returned by InteractiveMessage_TextParameter.Validate if the designated
// constraints aren't met.
type InteractiveMessage_TextParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_TextParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_TextParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_TextParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_TextParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_TextParameterValidationError) ErrorName() string {
	return "InteractiveMessage_TextParameterValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_TextParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_TextParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_TextParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_TextParameterValidationError{}

// Validate checks the field values on InteractiveMessage_Section with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InteractiveMessage_Section) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_Section with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InteractiveMessage_SectionMultiError, or nil if none found.
func (m *InteractiveMessage_Section) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_Section) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	for idx, item := range m.GetRows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InteractiveMessage_SectionValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InteractiveMessage_SectionValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InteractiveMessage_SectionValidationError{
					field:  fmt.Sprintf("Rows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InteractiveMessage_SectionMultiError(errors)
	}
	return nil
}

// InteractiveMessage_SectionMultiError is an error wrapping multiple
// validation errors returned by InteractiveMessage_Section.ValidateAll() if
// the designated constraints aren't met.
type InteractiveMessage_SectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_SectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_SectionMultiError) AllErrors() []error { return m }

// InteractiveMessage_SectionValidationError is the validation error returned
// by InteractiveMessage_Section.Validate if the designated constraints aren't met.
type InteractiveMessage_SectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_SectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_SectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_SectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_SectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_SectionValidationError) ErrorName() string {
	return "InteractiveMessage_SectionValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_SectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_Section.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_SectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_SectionValidationError{}

// Validate checks the field values on InteractiveMessage_ButtonsAction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InteractiveMessage_ButtonsAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_ButtonsAction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InteractiveMessage_ButtonsActionMultiError, or nil if none found.
func (m *InteractiveMessage_ButtonsAction) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_ButtonsAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetType() != "reply" {
		err := InteractiveMessage_ButtonsActionValidationError{
			field:  "Type",
			reason: "value must equal reply",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetReply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InteractiveMessage_ButtonsActionValidationError{
					field:  "Reply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InteractiveMessage_ButtonsActionValidationError{
					field:  "Reply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InteractiveMessage_ButtonsActionValidationError{
				field:  "Reply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InteractiveMessage_ButtonsActionMultiError(errors)
	}
	return nil
}

// InteractiveMessage_ButtonsActionMultiError is an error wrapping multiple
// validation errors returned by
// InteractiveMessage_ButtonsAction.ValidateAll() if the designated
// constraints aren't met.
type InteractiveMessage_ButtonsActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_ButtonsActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_ButtonsActionMultiError) AllErrors() []error { return m }

// InteractiveMessage_ButtonsActionValidationError is the validation error
// returned by InteractiveMessage_ButtonsAction.Validate if the designated
// constraints aren't met.
type InteractiveMessage_ButtonsActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_ButtonsActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_ButtonsActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_ButtonsActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_ButtonsActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_ButtonsActionValidationError) ErrorName() string {
	return "InteractiveMessage_ButtonsActionValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_ButtonsActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_ButtonsAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_ButtonsActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_ButtonsActionValidationError{}

// Validate checks the field values on InteractiveMessage_ActionWrapper with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InteractiveMessage_ActionWrapper) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_ActionWrapper with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InteractiveMessage_ActionWrapperMultiError, or nil if none found.
func (m *InteractiveMessage_ActionWrapper) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_ActionWrapper) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Button

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InteractiveMessage_ActionWrapperValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InteractiveMessage_ActionWrapperValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InteractiveMessage_ActionWrapperValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InteractiveMessage_ActionWrapperValidationError{
						field:  fmt.Sprintf("Sections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InteractiveMessage_ActionWrapperValidationError{
						field:  fmt.Sprintf("Sections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InteractiveMessage_ActionWrapperValidationError{
					field:  fmt.Sprintf("Sections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InteractiveMessage_ActionWrapperMultiError(errors)
	}
	return nil
}

// InteractiveMessage_ActionWrapperMultiError is an error wrapping multiple
// validation errors returned by
// InteractiveMessage_ActionWrapper.ValidateAll() if the designated
// constraints aren't met.
type InteractiveMessage_ActionWrapperMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_ActionWrapperMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_ActionWrapperMultiError) AllErrors() []error { return m }

// InteractiveMessage_ActionWrapperValidationError is the validation error
// returned by InteractiveMessage_ActionWrapper.Validate if the designated
// constraints aren't met.
type InteractiveMessage_ActionWrapperValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_ActionWrapperValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_ActionWrapperValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_ActionWrapperValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_ActionWrapperValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_ActionWrapperValidationError) ErrorName() string {
	return "InteractiveMessage_ActionWrapperValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_ActionWrapperValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_ActionWrapper.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_ActionWrapperValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_ActionWrapperValidationError{}

// Validate checks the field values on InteractiveMessage_Section_SectionRow
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InteractiveMessage_Section_SectionRow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InteractiveMessage_Section_SectionRow
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InteractiveMessage_Section_SectionRowMultiError, or nil if none found.
func (m *InteractiveMessage_Section_SectionRow) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_Section_SectionRow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for Description

	if len(errors) > 0 {
		return InteractiveMessage_Section_SectionRowMultiError(errors)
	}
	return nil
}

// InteractiveMessage_Section_SectionRowMultiError is an error wrapping
// multiple validation errors returned by
// InteractiveMessage_Section_SectionRow.ValidateAll() if the designated
// constraints aren't met.
type InteractiveMessage_Section_SectionRowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_Section_SectionRowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_Section_SectionRowMultiError) AllErrors() []error { return m }

// InteractiveMessage_Section_SectionRowValidationError is the validation error
// returned by InteractiveMessage_Section_SectionRow.Validate if the
// designated constraints aren't met.
type InteractiveMessage_Section_SectionRowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_Section_SectionRowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InteractiveMessage_Section_SectionRowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InteractiveMessage_Section_SectionRowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InteractiveMessage_Section_SectionRowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_Section_SectionRowValidationError) ErrorName() string {
	return "InteractiveMessage_Section_SectionRowValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_Section_SectionRowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_Section_SectionRow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_Section_SectionRowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_Section_SectionRowValidationError{}

// Validate checks the field values on
// InteractiveMessage_ButtonsAction_ButtonsActionReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InteractiveMessage_ButtonsAction_ButtonsActionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// InteractiveMessage_ButtonsAction_ButtonsActionReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError, or nil if
// none found.
func (m *InteractiveMessage_ButtonsAction_ButtonsActionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *InteractiveMessage_ButtonsAction_ButtonsActionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 1 || l > 256 {
		err := InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 20 {
		err := InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_InteractiveMessage_ButtonsAction_ButtonsActionReply_Title_Pattern.MatchString(m.GetTitle()) {
		err := InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError{
			field:  "Title",
			reason: "value does not match regex pattern \"^[^\\\\x{1F600}-\\\\x{1F6FF}|[\\\\x{2600}-\\\\x{26FF}]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError(errors)
	}
	return nil
}

// InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError is an error
// wrapping multiple validation errors returned by
// InteractiveMessage_ButtonsAction_ButtonsActionReply.ValidateAll() if the
// designated constraints aren't met.
type InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InteractiveMessage_ButtonsAction_ButtonsActionReplyMultiError) AllErrors() []error { return m }

// InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError is the
// validation error returned by
// InteractiveMessage_ButtonsAction_ButtonsActionReply.Validate if the
// designated constraints aren't met.
type InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) ErrorName() string {
	return "InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInteractiveMessage_ButtonsAction_ButtonsActionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InteractiveMessage_ButtonsAction_ButtonsActionReplyValidationError{}

var _InteractiveMessage_ButtonsAction_ButtonsActionReply_Title_Pattern = regexp.MustCompile("^[^\\x{1F600}-\\x{1F6FF}|[\\x{2600}-\\x{26FF}]*$")
